name: üöÄ D√©ployer une application
on:
  workflow_dispatch:
    inputs:
      deployment_type:
        description: "Type de d√©ploiement"
        required: true
        type: choice
        options:
          - "Nouvelle version d'application seulement (rapide)"
          - "Environnement complet (infrastructure + application)"
        default: "Nouvelle version d'application seulement (rapide)"
      branch_name:
        description: "Nom de la branche √† d√©ployer"
        required: true
        type: string
        default: "dev"
      environment_name:
        description: "Nom de l'environnement (par d√©faut: m√™me que la branche)"
        required: false
        type: string

# Permissions globales
permissions:
  id-token: write
  contents: read
  actions: write # N√©cessaire pour d√©clencher d'autres workflows

jobs:
  prepare_deployment:
    name: Pr√©parer le d√©ploiement
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.set_values.outputs.branch }}
      env_name: ${{ steps.set_values.outputs.env_name }}
      deployment_type: ${{ steps.set_values.outputs.deployment_type }}
    steps:
      - name: √âtablir les valeurs
        id: set_values
        run: |
          # D√©finir le nom de la branche
          BRANCH="${{ github.event.inputs.branch_name }}"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          
          # D√©finir le nom de l'environnement (utiliser le nom de branche si non fourni)
          if [ -z "${{ github.event.inputs.environment_name }}" ]; then
            ENV_NAME="${BRANCH}"
          else
            ENV_NAME="${{ github.event.inputs.environment_name }}"
          fi
          echo "env_name=$ENV_NAME" >> $GITHUB_OUTPUT
          
          # D√©finir le type de d√©ploiement (1=app only, 2=full)
          if [ "${{ github.event.inputs.deployment_type }}" = "Nouvelle version d'application seulement (rapide)" ]; then
            echo "deployment_type=app_only" >> $GITHUB_OUTPUT
          else
            echo "deployment_type=full" >> $GITHUB_OUTPUT
          fi
          
          # Afficher un r√©sum√©
          echo "üëâ Nom de branche: $BRANCH"
          echo "üëâ Nom d'environnement: $ENV_NAME"
          echo "üëâ Type de d√©ploiement: ${{ github.event.inputs.deployment_type }}"

  # ===== Option App Only - D√©ploiement de l'application seulement =====
  validate_environment:
    name: Valider l'environnement (App Only)
    if: needs.prepare_deployment.outputs.deployment_type == 'app_only'
    needs: prepare_deployment
    runs-on: ubuntu-latest
    outputs:
      environment_name: ${{ steps.clean_name.outputs.result }}
    steps:
      - name: Clean environment name for resource naming
        id: clean_name
        uses: actions/github-script@v6
        with:
          script: |
            // Clean up the environment name
            const envName = '${{ needs.prepare_deployment.outputs.env_name }}'
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '');
            
            console.log(`Original name: ${{ needs.prepare_deployment.outputs.env_name }}`);
            console.log(`Sanitized name: ${envName}`);
            return envName;

  check_resources:
    name: V√©rifier si l'environnement existe (App Only)
    if: needs.prepare_deployment.outputs.deployment_type == 'app_only'
    needs: [prepare_deployment, validate_environment]
    runs-on: ubuntu-latest
    outputs: 
      exists: ${{ steps.check.outputs.result }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE}}
      - name: Check if environment resources exist
        id: check
        uses: actions/github-script@v6
        with:
          script: |
            const { execSync } = require('child_process');
            
            try {
              // Try to get info about the ECS service - this will fail if it doesn't exist
              const cmd = `aws ecs describe-services --cluster ${{ vars.APPLICATION_ID }}-${{ needs.validate_environment.outputs.environment_name }} --services ${{ vars.APPLICATION_ID }}-${{ needs.validate_environment.outputs.environment_name }}`;
              execSync(cmd);
              console.log('Environment exists');
              return true;
            } catch (error) {
              console.log('Environment does not exist: ' + error.message);
              return false;
            }

  error_if_not_exists:
    name: Erreur si l'environnement n'existe pas (App Only)
    if: needs.prepare_deployment.outputs.deployment_type == 'app_only' && needs.check_resources.outputs.exists == 'false'
    needs: [prepare_deployment, check_resources, validate_environment]
    runs-on: ubuntu-latest
    steps:
      - name: Fail workflow
        run: |
          echo "ERREUR: L'environnement '${{ needs.validate_environment.outputs.environment_name }}' n'existe pas."
          echo "Vous devez d'abord le cr√©er en utilisant le d√©ploiement d'environnement complet."
          exit 1

  docker_build:
    name: Construire l'image Docker (App Only)
    if: needs.prepare_deployment.outputs.deployment_type == 'app_only' && needs.check_resources.outputs.exists == 'true'
    needs: [prepare_deployment, check_resources, validate_environment]
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT: ${{ needs.validate_environment.outputs.environment_name }}
      PREFIX: ${{ vars.APPLICATION_ID }}-${{ needs.validate_environment.outputs.environment_name }}
      IMAGE_TAG: ${{ github.run_number }}-${{ github.run_attempt}}
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Build, tag, and push image to Amazon ECR
        working-directory: .
        run: |
          # Build the Docker image
          docker build -t ${{ vars.APPLICATION_ID }}-$ENVIRONMENT . \
          --build-arg NEXT_PUBLIC_BASE_URL=${{ vars.NEXT_PUBLIC_BASE_URL }} \
          --build-arg BUILD_ID=${{ github.run_id }} \
          --build-arg BUILD_NUMBER=${{ github.run_number }}-${{ github.run_attempt}} \
          --build-arg BUILD_SOURCE_VERSION=${{ github.sha }}
          
          # Tag and push to ECR
          docker tag ${{ vars.APPLICATION_ID }}-$ENVIRONMENT:latest ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.APPLICATION_ID }}-$ENVIRONMENT:$IMAGE_TAG
          docker push ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.APPLICATION_ID }}-$ENVIRONMENT:$IMAGE_TAG
          
          echo "New image pushed: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.APPLICATION_ID }}-$ENVIRONMENT:$IMAGE_TAG"

  update_service:
    name: Mettre √† jour le service ECS (App Only)
    if: needs.prepare_deployment.outputs.deployment_type == 'app_only' && needs.check_resources.outputs.exists == 'true'
    needs: [prepare_deployment, docker_build, validate_environment, check_resources]
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT: ${{ needs.validate_environment.outputs.environment_name }}
      PREFIX: ${{ vars.APPLICATION_ID }}-${{ needs.validate_environment.outputs.environment_name }}
      IMAGE_TAG: ${{ github.run_number }}-${{ github.run_attempt}}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE}}
      - name: Update ECS service
        run: |
          # Get current task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition $PREFIX-ecs-taskdef --query 'taskDefinition' --output json)
          
          # Create new task definition with the new image
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.APPLICATION_ID }}-$ENVIRONMENT:$IMAGE_TAG" '.containerDefinitions[0].image = $IMAGE')
          
          # Register new task definition
          FAMILY=$(echo $TASK_DEFINITION | jq -r '.family')
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --family $FAMILY \
            --container-definitions "$(echo $NEW_TASK_DEFINITION | jq '.containerDefinitions')" \
            --task-role-arn "$(echo $TASK_DEFINITION | jq -r '.taskRoleArn')" \
            --execution-role-arn "$(echo $TASK_DEFINITION | jq -r '.executionRoleArn')" \
            --network-mode "$(echo $TASK_DEFINITION | jq -r '.networkMode')" \
            --volumes "$(echo $TASK_DEFINITION | jq '.volumes')" \
            --cpu "$(echo $TASK_DEFINITION | jq -r '.cpu')" \
            --memory "$(echo $TASK_DEFINITION | jq -r '.memory')" \
            --requires-compatibilities "$(echo $TASK_DEFINITION | jq '.requiresCompatibilities')" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          # Update the service
          aws ecs update-service \
            --cluster $PREFIX \
            --service $PREFIX \
            --task-definition $NEW_TASK_DEF_ARN \
            --force-new-deployment
          
          echo "Service ECS mis √† jour avec la nouvelle d√©finition de t√¢che: $NEW_TASK_DEF_ARN"
          echo "D√©ploiement en cours. Consultez la console AWS pour le statut."

  # ===== Option Full Deploy - D√©ploiement complet =====
  deploy_iam:
    name: D√©ployer IAM (Full Deploy)
    if: needs.prepare_deployment.outputs.deployment_type == 'full'
    needs: prepare_deployment
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE}}
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "yarn"
          cache-dependency-path: infra/yarn.lock
      - name: Sanitize branch name
        id: sanitize
        uses: actions/github-script@v6
        with:
          script: |
            const branchName = '${{ needs.prepare_deployment.outputs.branch }}'
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '');
            
            const truncated = branchName.substring(0, 20);
            return truncated;
      - name: Set environment variables
        run: |
          echo "ENVIRONMENT=${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
          echo "PREFIX=${{ vars.APPLICATION_ID }}-${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
      - name: Install project dependencies
        run: cd infra && yarn install
      - name: Bootstrap CDK
        working-directory: infra
        run: |
          yarn cdk bootstrap
      - name: Deploy IAM
        working-directory: infra
        run: |
          yarn cdk:deploy:iam-stack

  deploy_ecr:
    name: D√©ployer ECR (Full Deploy)
    if: needs.prepare_deployment.outputs.deployment_type == 'full'
    needs: [prepare_deployment, deploy_iam]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE}}
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "yarn"
          cache-dependency-path: infra/yarn.lock
      - name: Sanitize branch name
        id: sanitize
        uses: actions/github-script@v6
        with:
          script: |
            const branchName = '${{ needs.prepare_deployment.outputs.branch }}'
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '');
            
            const truncated = branchName.substring(0, 20);
            return truncated;
      - name: Set environment variables
        run: |
          echo "ENVIRONMENT=${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
          echo "PREFIX=${{ vars.APPLICATION_ID }}-${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
      - name: Install project dependencies
        run: cd infra && yarn install
      - name: Deploy ECR
        working-directory: infra
        run: |
          yarn cdk:deploy:ecr-stack

  build_docker_full:
    name: Construire Docker (Full Deploy)
    if: needs.prepare_deployment.outputs.deployment_type == 'full'
    needs: [prepare_deployment, deploy_ecr]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE }}
      - name: Sanitize branch name
        id: sanitize
        uses: actions/github-script@v6
        with:
          script: |
            const branchName = '${{ needs.prepare_deployment.outputs.branch }}'
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '');
            
            const truncated = branchName.substring(0, 20);
            return truncated;
      - name: Set environment variables
        run: |
          echo "ENVIRONMENT=${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
          echo "PREFIX=${{ vars.APPLICATION_ID }}-${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ github.run_number }}-${{ github.run_attempt}}" >> $GITHUB_ENV
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Build, tag, and push image to Amazon ECR
        working-directory: .
        run: |
          docker build -t ${{ vars.APPLICATION_ID }}-$ENVIRONMENT . \
          --build-arg NEXT_PUBLIC_BASE_URL=${{ vars.NEXT_PUBLIC_BASE_URL }} \
          --build-arg BUILD_ID=${{ github.run_id }} \
          --build-arg BUILD_NUMBER=${{ github.run_number }}-${{ github.run_attempt}} \
          --build-arg BUILD_SOURCE_VERSION=${{ github.sha }}
          docker tag ${{ vars.APPLICATION_ID }}-$ENVIRONMENT:latest ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.APPLICATION_ID }}-$ENVIRONMENT:$IMAGE_TAG
          docker push ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.APPLICATION_ID }}-$ENVIRONMENT:$IMAGE_TAG

  deploy_ecs:
    name: D√©ployer ECS (Full Deploy)
    if: needs.prepare_deployment.outputs.deployment_type == 'full'
    needs: [prepare_deployment, build_docker_full]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE}}
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "yarn"
          cache-dependency-path: infra/yarn.lock
      - name: Sanitize branch name
        id: sanitize
        uses: actions/github-script@v6
        with:
          script: |
            const branchName = '${{ needs.prepare_deployment.outputs.branch }}'
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '');
            
            const truncated = branchName.substring(0, 20);
            return truncated;
      - name: Set environment variables
        run: |
          echo "ENVIRONMENT=${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
          echo "PREFIX=${{ vars.APPLICATION_ID }}-${{ steps.sanitize.outputs.result }}" >> $GITHUB_ENV
      - name: Install project dependencies
        run: cd infra && yarn install
      - name: Deploy ECS
        working-directory: infra
        run: |
          yarn cdk:deploy:ecs-stack

  show_success:
    name: Afficher le succ√®s
    needs: [
      prepare_deployment, 
      validate_environment, check_resources, docker_build, update_service,
      deploy_iam, deploy_ecr, build_docker_full, deploy_ecs
    ]
    if: >-
      always() && 
      (
        (needs.prepare_deployment.outputs.deployment_type == 'app_only' && needs.update_service.result == 'success') || 
        (needs.prepare_deployment.outputs.deployment_type == 'full' && needs.deploy_ecs.result == 'success')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Message de succ√®s
        run: |
          echo "‚úÖ Le d√©ploiement a √©t√© compl√©t√© avec succ√®s!"
          echo "üìä D√©tails du d√©ploiement:"
          echo "  ‚Ä¢ Type: ${{ github.event.inputs.deployment_type }}"
          echo "  ‚Ä¢ Branche: ${{ needs.prepare_deployment.outputs.branch }}"
          
          if [ "${{ needs.prepare_deployment.outputs.deployment_type }}" = "app_only" ]; then
            echo "  ‚Ä¢ Environnement: ${{ needs.validate_environment.outputs.environment_name }}"
            echo ""
            echo "üîç L'application a √©t√© mise √† jour et est en cours de d√©ploiement"
          else
            echo "  ‚Ä¢ Environnement: $ENVIRONMENT"
            echo ""
            echo "üîç L'environnement complet a √©t√© d√©ploy√©"
            echo "‚è≥ Vous pouvez acc√©der √† l'application via le Load Balancer URL dans la console AWS"
          fi 
